/*
// in https://github.com/adafruit/Adafruit_NeoPixel/blob/master/Adafruit_NeoPixel.h#L183
// gamma is 2.6, let's tone down a bit
import math
gamma=2.0
for x in range(256):
    print(f"{int(math.pow((x)/255.0,gamma)*255.0+0.5)},", end='\n' if x&15 == 15 else '')
*/


// https://silverhammermba.github.io/blog/2017/12/01/gamma
static const uint8_t PROGMEM Gamma18[256] = {
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,
2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,6,
6,6,7,7,8,8,8,9,9,10,10,10,11,11,12,12,
13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,21,
21,22,22,23,24,24,25,26,26,27,28,28,29,30,30,31,
32,32,33,34,35,35,36,37,38,38,39,40,41,41,42,43,
44,45,46,46,47,48,49,50,51,52,53,53,54,55,56,57,
58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,
74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,
91,92,93,95,96,97,98,99,100,102,103,104,105,107,108,109,
110,111,113,114,115,116,118,119,120,122,123,124,126,127,128,129,
131,132,134,135,136,138,139,140,142,143,145,146,147,149,150,152,
153,154,156,157,159,160,162,163,165,166,168,169,171,172,174,175,
177,178,180,181,183,184,186,188,189,191,192,194,195,197,199,200,
202,204,205,207,208,210,212,213,215,217,218,220,222,224,225,227,
229,230,232,234,236,237,239,241,243,244,246,248,250,251,253,255
};

static const uint8_t PROGMEM Gamma20[256] = {
0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,3,3,3,3,4,4,
4,4,5,5,5,5,6,6,6,7,7,7,8,8,8,9,
9,9,10,10,11,11,11,12,12,13,13,14,14,15,15,16,
16,17,17,18,18,19,19,20,20,21,21,22,23,23,24,24,
25,26,26,27,28,28,29,30,30,31,32,32,33,34,35,35,
36,37,38,38,39,40,41,42,42,43,44,45,46,47,47,48,
49,50,51,52,53,54,55,56,56,57,58,59,60,61,62,63,
64,65,66,67,68,69,70,71,73,74,75,76,77,78,79,80,
81,82,84,85,86,87,88,89,91,92,93,94,95,97,98,99,
100,102,103,104,105,107,108,109,111,112,113,115,116,117,119,120,
121,123,124,126,127,128,130,131,133,134,136,137,139,140,142,143,
145,146,148,149,151,152,154,155,157,158,160,162,163,165,166,168,
170,171,173,175,176,178,180,181,183,185,186,188,190,192,193,195,
197,199,200,202,204,206,207,209,211,213,215,217,218,220,222,224,
226,228,230,232,233,235,237,239,241,243,245,247,249,251,253,255
};

static const uint8_t PROGMEM Gamma22[256] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,
3,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,
6,7,7,7,8,8,8,9,9,9,10,10,11,11,11,12,
12,13,13,13,14,14,15,15,16,16,17,17,18,18,19,19,
20,20,21,22,22,23,23,24,25,25,26,26,27,28,28,29,
30,30,31,32,33,33,34,35,35,36,37,38,39,39,40,41,
42,43,43,44,45,46,47,48,49,49,50,51,52,53,54,55,
56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
73,74,75,76,77,78,79,81,82,83,84,85,87,88,89,90,
91,93,94,95,97,98,99,100,102,103,105,106,107,109,110,111,
113,114,116,117,119,120,121,123,124,126,127,129,130,132,133,135,
137,138,140,141,143,145,146,148,149,151,153,154,156,158,159,161,
163,165,166,168,170,172,173,175,177,179,181,182,184,186,188,190,
192,194,196,197,199,201,203,205,207,209,211,213,215,217,219,221,
223,225,227,229,231,234,236,238,240,242,244,246,248,251,253,255
};

CRGB gamma32(CRGB x, byte gamma = 18) {
//  uint8_t *y = (uint8_t *)&x;
  // All four bytes of a 32-bit value are filtered even if RGB (not WRGB),
  // to avoid a bunch of shifting and masking that would be necessary for
  // properly handling different endianisms (and each byte is a fairly
  // trivial operation, so it might not even be wasting cycles vs a check
  // and branch for the RGB case). In theory this might cause trouble *if*
  // someone's storing information in the unused most significant byte
  // of an RGB value, but this seems exceedingly rare and if it's
  // encountered in reality they can mask values going in or coming out.
  for (uint8_t i = 0; i < 3; i++) {
    switch (gamma) {
      case 18:
        x[i] = pgm_read_byte(&Gamma18[x[i]]); break;
      case 20:
        x[i] = pgm_read_byte(&Gamma20[x[i]]); break;
      case 22:
        x[i] = pgm_read_byte(&Gamma22[x[i]]); break;
    }
  }
  return x; // Packed 32-bit return
}
