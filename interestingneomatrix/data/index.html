<html>
	<head>
		<title>everything is interesting once</title>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&family=IBM+Plex+Sans:wght@300;500&family=IBM+Plex+Serif:ital,wght@1,300&display=swap" rel="stylesheet">
		<style type="text/css">
		html {
			overflow: hidden;
		}
		html, body, input, select {
			margin: 0;
			background-color: #000;
			color: #fff;
			font-family: "IBM Plex Sans", "Courier", serif;
			font-weight: 300;
			text-size-adjust: auto;
		}
		body {
			position: absolute;
			top: 50%;
			left: 50%;
			-ms-transform: translate(-50%, -50%);
			transform: translate(-50%, -50%);
			height: fit-content;
			max-height: 100%;
			width: 100%;
			max-width: 50em;
			padding: 1em 0 7em;
		}
		input {
			font-family: "IBM Plex Mono", fixed;
			text-align: center;
		}
		.gradient {
			display: inline-block;
			height: .8em;
			width: 4em;
			margin: 1em 0.5em;
		}
		.gradient.smol {
			height: .4em;
		}
		.gradient.lowres {
			background-image: linear-gradient(to right, red 20%,yellow 20%,yellow 40%,lime 40%,lime 60%,blue 60%,blue 80%,violet 80%);
		}
		.gradient.highres {
			background-image: linear-gradient(to right, red,orange,yellow,green,blue,indigo,violet);
		}
		.gradient.hsv {
			background-image: linear-gradient(to right, hsl(0, 100%, 50%) 0%, hsl(40, 100%, 50%) 25%, hsl(80, 100%, 50%) 50%, hsl(120, 100%, 50%) 75%, hsl(160, 100%, 50%) 100%);
		}
		.gradient.rgb {
			background-image: linear-gradient(to right, hsl(0, 100%, 50%) 0%, hsl(160, 100%, 50%) 100%);
		}
		.gradient.ftb {
			background-image: linear-gradient(to right, hsl(0, 100%, 50%) 20%, #000);
		}
		.gradient.flicker {
			background-image: linear-gradient(to right, hsl(0, 100%, 50%), hsl(0, 100%, 10%) 40%, hsl(0, 100%, 30%) 50%, hsl(0, 100%, 5%) 60%, hsl(0, 100%, 20%) 70%, hsl(0, 100%, 0%) 80%, hsl(0, 100%, 10%) 90%, #000);
		}
		.row, .triple {
			display: flex;
			flex-direction: row;
			align-items: center;
		}
		.triple {
			width: 100%;
			align-items: stretch;
			position: relative;
		}
		.triple > div {
			flex: 1 1 auto;
			justify-content: center;
		}
		.triple > div:nth-child(2) {
			flex: 0 0 4em;
			position: absolute; /* exclude from flex calculations */
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			display: flex;
		}
		.col {
			display: flex;
			flex-direction: column;
			align-items: center;
		}
		#controls {
			margin: auto;
			width: 90%;
			max-width: 40em;
			gap: 1em;
		}
		.transitioncontrols, .triple > div {
			gap: 1em 0;
		}
		#crossfader {
			-webkit-appearance: none;
			width: 10em;
			align-self: center;
			height: 15px;
			border-radius: 5px;
			background: #444;
			outline: none;
			opacity: 0.7;
			-webkit-transition: .2s;
			transition: opacity .2s;
		}

		#crossfader::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 1em;
			height: 5em;
			border-radius: 25%;
			background: #fff;
			cursor: pointer;
		}

		#signature {
			position: absolute;
			bottom: 0;
			right: 2em;
			text-align: right;
			font-family: "IBM Plex Serif", serif;
			font-style: italic;
		}
		h1 {
			margin-top: 0;
			font-family: "IBM Plex Sans", sans-serif;
			font-style: normal;
			font-weight: 500;
		}

	.switch {
	position: relative;
	display: inline-block;
	width: 2.7em;
	height: 1.2em;
	}

	/* Hide default HTML checkbox */
	.switch input {
	opacity: 0;
	width: 0;
	height: 0;
	}
	.slider {
	position: absolute;
	cursor: pointer;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background-color: #fff;
	transition: .4s;
	border-radius: 1em;
	}

	.slider:before {
	position: absolute;
	content: "";
	height: .7em;
	width: .7em;
	left: .25em;
	bottom: .25em;
	background-color: #000;
	-webkit-transition: .4s;
	transition: .4s;
	border-radius: 50%;
	}

	input:focus + .slider {
		box-shadow: 0 0 1px #2196F3;
	}

	input:checked + .slider:before {
		transform: translateX(1.5em);
	}
	.markerbounds {
	}
	.box {
		width: 8em;
		height: 8em;
		position: relative;
	}
	.box > div {
		position: absolute;
		top: 0;
		left: 0;
		bottom: 0;
		right: 0;
		background-color: #111;
		border-radius: .3em;
		z-index: -1;
		display: flex;
		justify-content: center;
		align-items: center;
		color: #666;
		font-size: 1.2em;
		font-weight: 500;
	}
	.box > button {
		position: relative;
		transform: translate(-50%, -50%);
		width: 1em;
		height: 1em;
		border-radius: 50%;
		border: none;
		cursor: grab;
	}
	</style>
	</head>
	<body>
		<div id="controls" class="col">
		<!-- <div>you’re standing in front of a little colourful LED display box, the kind of cheap consumer entertainment gimmick that you might come across in a discount toy shop. it’s not clear why anyone ever buys such a thing, but once it has made its way into someone’s home it will provide entertainment for the whole family for no more than a few hours before it ends up in a drawer to collect dust. still, in this moment, it somehow manages to draw you in with its little flickering lights. it certainly lacks the dazzling sway of the newest high-tech, and it doesn’t have the chic nostalgia of some truly retro technology speaking for it either. it sits on uncomfortable middle ground, desperately trying to draw your attention to it for just a second longer, before it disappears as just another faint memory in the endless stream of impressions that is hurled in your face on a daily basis.</div> -->
		</div>
		<div id="signature">a product by<h1>the Futile Corporation</h1></div>
	</body>
	<script type="text/javascript">
	const setValueImmediate = (target, value) => {
		fetch(target, { method: 'POST', body: value }).then();
	};
	const debounce = (func, waitFor) => {
		let timeout;
		return (...args) => new Promise(resolve => {
			if (timeout) {
				clearTimeout(timeout);
			}
			timeout = setTimeout(() => resolve(func(...args)), waitFor);
		});
	}
	// handle debouncers -- this implements per-item rate limiting, but not global
	let debouncedSetValue = {};
	const setValue = (target, value) => {
		if (!Object.keys(debouncedSetValue).includes(target)) {
			debouncedSetValue[target] = debounce(setValueImmediate, 100);
		}
		debouncedSetValue[target](target, value);
	};
	const fetchCallback = (target, field, extraCallback = '') => {
		return "\"fetch('" + target + "', { method: 'POST', body: this." + field + " } ).then(r => {" + extraCallback + "})\"";
	}

	const range = (id, value, mn, mx, step = 1) => {
		let attribs = `value="${value}" min="${String(mn)}" max="${String(mx)}" step="${String(step)}"`;
		return `<input type="range" id="${id}" ${attribs} oninput="setValueImmediate('${id}', this.value)" list="steplist"/><datalist id="steplist"> <option>1</option> <option>2</option> <option>3</option> <option>4</option> <option>5</option><option>6</option><option>7</option><option>8</option> <option>9</option><option>10</option><option>11</option> <option>12</option></datalist>`;
	}

	const dropdown = (id, options, n, selectedIndex, startAt = 0) => {
		let s = "<select onchange=" + fetchCallback(id, "value") + ">";
		for (let i = startAt; i < n; i++) {
			s += "<option value=\"" + i + "\"" + ((i == selectedIndex) ? " selected" : "") + ">" + options[i] + "</option>";
		}
		return s + "</select>";
	}

	const controls = document.getElementById('controls');
	controls.innerHTML = `<input type="text" style="font-size: 2em; width: 20em;" maxlength="40" value="|msg|" oninput="setValue('msg', this.value)" />` + controls.innerHTML;
	controls.innerHTML += '<div class="row"><div class="gradient lowres"></div>' + range("hue", |resolution|, 1, 8) + '<div class="gradient highres"></div></div>';
	// left: rotate hue or blend colors, right: fade-to-black or flicker
	// make sliders vertical??
	// - fixed on time (extra time is fixed proportion?)
	// - transition duration: fixed and extra (could create 2d slider???)
	// - drift/noise
	// 3 2d sliders:
	// 1. 'rest'
	// 2. 'transition'
	// 3. 'difference'
	const toggle = (id, extra='') => {
		// transition0 is 3 unchecked, 2 checked
		// transition1 is 1 unchecked, 4 checked
		const base = (id == '0t') ? 3 : 1;
		const inc = (id == '0t') ? -1 : 3;
		return `<label id="${id}" class="switch"> <input type="checkbox" onchange="setValueImmediate('${id}', ${base} + this.checked * ${inc})" ${extra}> <span class="slider"></span> </label>`;
	};
	const slider2d = (label, xid, x, xmin, xmax, yid, y, ymin, ymax) => {
		const xp = Math.max(0, Math.min(Math.round(100 * ( x - xmin ) / ( xmax - xmin )), 100));
		// watch out: y is flipped around (measured as distance from bottom, rather than top like the css)
		const yp = Math.max(0, Math.min(Math.round(100 * ( y - ymax ) / ( ymin - ymax )), 100));
		// data-ymin/ymax also flipped here
		return `<div class="markerbounds"> <div class="box" data-xid="${xid}" data-xmin="${xmin}" data-xmax="${xmax}" data-yid="${yid}" data-ymin="${ymax}" data-ymax="${ymin}"><div>${label}</div><button style="left: ${xp}%; top: ${yp}%;"></button></div></div>`;
	};
	const transitioncontrols = (i, on1, on2, q, roroff, n, d) => {
		return `<div class="col">${slider2d("rest", i + "on1", on1, 10, 3000, i + "on2", on2, 0, 2000)}${slider2d("motion", i + "q", q, 2000, 100, i + (i == 1 ? "r" : "off"), roroff, 2000, 0)}${slider2d("change", i + "n", n, 30, 126, i + "d", d, 0, 100)}</div>`;
	};
	controls.innerHTML += `<div class="triple"><div class="row"><div class="gradient smol rgb"></div>${toggle('0t', "|radial|")}<div class="gradient smol hsv"></div></div><div></div><div class="row"><div class="gradient smol ftb"></div>${toggle("1t", "|flicker|")}<div class="gradient smol flicker"></div></div></div><div class="triple">${transitioncontrols(0, |0on1|, |0on2|, |0q|, |0r|, |0n|, |0d|)}<div>${range('0l', |crossfade|, 1, 10000)}</div>${transitioncontrols(1, |1on1|, |1on2|, |1q|, |1off|, |1n|, |1d|)}</div>`;
	const boxes = document.getElementsByClassName("box");
	const setPercent = (box, x, y) => {
		const xp = Math.max(0, Math.min(x / box.clientWidth, 1));
		const yp = Math.max(0, Math.min(y / box.clientHeight, 1));
		box.lastElementChild.style.left = Math.round(100*xp) + "%";
		box.lastElementChild.style.top = Math.round(100*yp) + "%";
		setValue(box.dataset.xid, Math.round(parseInt(box.dataset.xmin) + xp*(box.dataset.xmax-box.dataset.xmin)));
		setValue(box.dataset.yid, Math.round(parseInt(box.dataset.ymin) + yp*(box.dataset.ymax-box.dataset.ymin)));
	};
	const jumpto = (e) => {
		if (e.target.nodeName == "DIV") {
			setPercent(e.target, e.offsetX, e.offsetY);
		}
	};
	const dragstart = (e) => {
		e.target.dataset.dragging = e.pointerId;
	}
	const drag = (e) => {
		const onButton = e.target.nodeName == "BUTTON";
		const button = onButton ? e.target : e.target.lastElementChild;
		if (button.dataset.dragging == e.pointerId) {
			if (onButton) {
				setPercent(e.target.parentElement, e.target.offsetLeft - e.target.offsetWidth/2 + e.offsetX, e.target.offsetTop - e.target.offsetHeight/2 + e.offsetY);
			} else {
				// mouse was moved to quickly so lost track of the button, now just hovering the box
				// pretty sure this is right
				setPercent(e.target, e.offsetX, e.offsetY);
			}
		}
	};
	const dragend = (e) => {
		console.log(e);
		for (let box of document.getElementsByClassName("box")) {
			if (e.pointerId == box.lastElementChild.dataset.dragging) {
				box.lastElementChild.dataset.dragging = undefined;
			}
		}
	};

	for (box of boxes) {
		box.onclick = jumpto;
		box.lastChild.onpointerdown = dragstart;
		box.onpointermove = drag;
	}
	document.body.addEventListener('pointerup', dragend);
	</script>
</html>
